[{"title":"麻将类胡牌算法","date":"2017-08-03T09:32:55.858Z","path":"2017/08/03/mj_server_arithmetic/","text":"第一次做麻将服务端，记录下相关算法 胡牌算法1234567891011/* *理牌*/ public static int[] LayCards(List&lt;Poker&gt; cardList) &#123; int nCardsLay[] = new int[MJ_LAYOUT_NUM]; for (Poker p : cardList) &#123; nCardsLay[p.getCode()]++; &#125; return nCardsLay; &#125; 12345678910111213141516171819202122232425262728293031323334/* *验证输入已经理好的牌型是否满足 3*N规则*/public static boolean fitThreePairsForLayCards(int laycards[]) &#123; int i = 0; for (;i &lt; MJ_LAYOUT_NUM; i++) &#123; if (laycards[i]&gt;0) &#123; break; &#125; &#125; if(i==MJ_LAYOUT_NUM) return true; for(i=0;i&lt;MJ_LAYOUT_NUM;i++) &#123; if (laycards[i]==0) continue; else if (laycards[i]==3) &#123; laycards[i] =0; return fitThreePairsForLayCards(laycards); &#125; else if (i&lt;28&amp;&amp;laycards[i]&gt;0&amp;&amp;laycards[i+1]&gt;0&amp;&amp;laycards[i+2]&gt;0) &#123; laycards[i]--; laycards[i+1]--; laycards[i+2]--; return fitThreePairsForLayCards(laycards); &#125; else &#123; return false; &#125; &#125; return true; &#125; 123456789101112131415161718192021222324252627/* *验证输入未理过的牌型是否满足 3*N规则(区分花色) */ public static boolean fitThreePairs(List&lt;Poker&gt; cardList) &#123; if (cardList.isEmpty()) &#123; return true; &#125; Map&lt;Suit,List&lt;Poker&gt;&gt; suit_pokers = new HashMap&lt;Suit, List&lt;Poker&gt;&gt;(); suit_pokers.put(Suit.TIAO, new ArrayList&lt;Poker&gt;()); suit_pokers.put(Suit.TONG, new ArrayList&lt;Poker&gt;()); suit_pokers.put(Suit.WAN, new ArrayList&lt;Poker&gt;()); suit_pokers.put(Suit.ZI, new ArrayList&lt;Poker&gt;()); for (Poker var:cardList) &#123; suit_pokers.get(var.getSuit()).add(var); &#125; for ( Suit suit:suit_pokers.keySet()) &#123; int[] laycards = LayCards(suit_pokers.get(suit)); if (!fitThreePairsForLayCards(laycards)) &#123; return false; &#125; &#125; return true; &#125; 123456789101112131415161718192021222324/* *胡牌算法入口函数 *1.找出牌型中所有两张以上的牌型并去除,作为将 *2.验证剩下牌型是否满足 3*N 规则*/ public static boolean analyzeNormalHu(List&lt;Poker&gt; cards) &#123; if (cards.size()%3!=2) &#123; return false; &#125; List&lt;Poker&gt; plist = new ArrayList&lt;Poker&gt;(); plist.addAll(cards); Collections.sort(plist, comparator); for (Poker p:plist) &#123; if (Collections.frequency(plist, p) &gt;= 2) &#123; List&lt;Poker&gt; wipe2jiangplist = new ArrayList&lt;Poker&gt;(plist); wipe2jiangplist.remove(p); wipe2jiangplist.remove(p); if (fitThreePairs(wipe2jiangplist)) &#123; return true; &#125; &#125; &#125; return false; &#125;","tags":[{"name":"mahjongsever","slug":"mahjongsever","permalink":"http://yoursite.com/tags/mahjongsever/"}]},{"title":"Sudoku Solver","date":"2017-02-13T02:21:51.000Z","path":"2017/02/13/leetcode_2_SudokuSolver/","text":"DescriptionWrite a program to solve a Sudoku puzzle by filling the empty cells.Empty cells are indicated by the character ‘.’.You may assume that there will be only one unique solution. Example:A sudoku puzzle… …and its solution numbers marked in red. leetcode : https://leetcode.com/problems/sudoku-solver/ Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111const int MAX_SIZE = 9; // 九宫格struct Pos &#123; Pos(int x, int y) : row(x), col(y) &#123;&#125;; int row; int col;&#125;;typedef deque &lt;Pos&gt; qpos;qpos Q; // 记录要放置数字的位置// 九宫格数组，0表示玩家要放置数字的位置int sudoku[MAX_SIZE][MAX_SIZE] = &#123; &#123; 5, 3, 0, 0, 7, 0, 0, 0, 0 &#125;, &#123; 6, 0, 0, 1, 9, 5, 0, 0, 0 &#125;, &#123; 0, 9, 8, 0, 0, 0, 0, 6, 0 &#125;, &#123; 8, 0, 0, 0, 6, 0, 0, 0, 3 &#125;, &#123; 4, 0, 0, 8, 0, 3, 0, 0, 1 &#125;, &#123; 7, 0, 0, 0, 2, 0, 0, 0, 6 &#125;, &#123; 0, 6, 0, 0, 0, 0, 2, 8, 0 &#125;, &#123; 0, 0, 0, 4, 1, 9, 0, 0, 5 &#125;, &#123; 0, 0, 0, 0, 8, 0, 0, 7, 9 &#125;,&#125;;void printSudoku()&#123; cout &lt;&lt; \"-------------------------\" &lt;&lt; endl; for (int i = 0; i &lt; MAX_SIZE; i++) &#123; for (int j = 0; j &lt; MAX_SIZE; j++) &#123; if (j % 3 == 0) &#123; cout &lt;&lt; \"| \"; &#125; cout &lt;&lt; sudoku[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; \"| \"; cout &lt;&lt; endl; if ((i + 1) % 3 == 0) &#123; cout &lt;&lt; \"-------------------------\" &lt;&lt; endl; &#125; &#125;&#125;bool check(Pos p, int n)&#123; int cur_row = p.row; int cur_col = p.col; // 验证行列是否合格 for (int i = 0; i &lt; MAX_SIZE; i++) &#123; if (n == sudoku[i][cur_col] || n == sudoku[cur_row][i]) &#123; return false; &#125; &#125; // 验证九宫格内是无复生数字 int grid_row = (cur_row / 3) * 3; int grid_col = (cur_col / 3) * 3; for (int i = 0; i &lt; 3; i++) &#123; if (n == sudoku[grid_row][i + grid_col] || n == sudoku[grid_row + i][grid_col]) &#123; return false; &#125; &#125; return true;&#125;bool place(qpos &amp; Q)&#123; // 递归结束条件为没有要断续放置数字的位置 if (Q.empty()) &#123; printSudoku(); return true; &#125; Pos cur(Q.front().row, Q.front().col); // 当前需要放置的位置信息 Q.pop_front(); for (int i = 1; i &lt;= 9; i++) &#123; // 从1到9轮流尝试 if (check(cur, i)) &#123; sudoku[cur.row][cur.col] = i; // 放置数字i到当前位置 if (!place(Q)) &#123; // 放置下一位置 // 下一位置放置失败，则在当前位置尝试放置下一个i sudoku[cur.row][cur.col] = 0; // 将当前位置值重置 &#125; else &#123; // 下一位置放置成功 return true; &#125; &#125; &#125; Q.push_front(cur); //当前位置不论怎么放置数字，下一位置都无法放置成功， // 重新插入该位置信息，返回上一级放置位置 return false;&#125;int main(int argc,char*argv)&#123; // Q中保存需要放置数字的位置 for (int i = 0; i &lt; MAX_SIZE; i++) &#123; for (int j = 0; j &lt; MAX_SIZE; j++) &#123; if (0 == sudoku[i][j]) &#123; Q.push_back(Pos(i, j)); &#125; &#125; &#125; place(Q); printf(\"\\n--------------------------------------------------\\n\"); system(\"pause\"); return 0;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"Find All Duplicates in an Array","date":"2017-02-10T05:28:00.000Z","path":"2017/02/10/leetcode_1_FindAllDuplicatesInAnArray/","text":"DescriptionGiven an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.Find all the elements that appear twice in this array.Could you do it without extra space and in O(n) runtime? leetcode : https://leetcode.com/problems/find-all-duplicates-in-an-array/ Example:Input:[4,3,2,7,8,2,3,1] Output:[2,3] Solution1234567891011121314151617181920vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return&#123;&#125;; vector&lt;int&gt; res; int n = nums.size(); for (int i = 0; i &lt; n; i++) nums[i] -= 1; //for indexing flexibility int i = 0; while (i &lt; n) &#123; if (nums[i] != nums[nums[i]]) swap(nums[i], nums[nums[i]]); //swap elements to their respective indexes. else i++; &#125; for (int i = 0; i &lt; n; i++) &#123; if (nums[i] != i) res.push_back(nums[i] + 1); //get the elements which are at some other indexes (as they are occuring twice) &#125; return res;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"位运算回顾","date":"2017-02-08T02:35:11.000Z","path":"2017/02/08/bitoperation/","text":"”&amp;“ 按位与如果两个相应的二进制位都为１，则该位的结果值为1；否则为0 “|” 按位或如果两个相应的二进制位只要有一个是1，结果就是1；否则为0。 if(n % 2 == 0) 等价于 if((n&amp;1) == 0) 后者运行效率更高 “&lt;&lt;“ 左位移向左移一位， 高位丢弃，低位补0n * 2 == (n &lt;&lt; 1) “&gt;&gt;” 右位移向右移一位，正数补0，负数补1n&gt;&gt;1 = n / 2 ^ 异或两个相同的数会变成0，反之是1void swap(int &amp;a,int &amp;b){ a^=b; b^=a; a^=b;}","tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"redis实用之session管理","date":"2017-01-24T07:11:45.657Z","path":"2017/01/24/node_redis_example_session/","text":"在游戏服务器里，登录服务器是必不可少的一块运用redis设置带时效的缓存，可以很好的解决session管理的问题。。 sessionManager用户登录1234567/** * 用户登录 */function LoginIn(userinfo) &#123; redishelper.setValueWithExpire(getNewSessionId(),userinfo,SESSION_EXPIRE);&#125; 用户登出123456789101112131415/** * 用户登出 */function loginOut(session_id) &#123; redishelper.getVaule(session_id,function(err,redis_result) &#123;if(!err)&#123; saveInfoToDB(redis_result); ////将缓存存储到数据库&#125; redishelper.del(session_id);&#125;);&#125;&#125; 判断用户是否登录12345678910111213141516171819/** * 判断用户是否登录 */function isLogin(session_id, callback) &#123; (function(session_id)&#123; redishelper.getVaule(session_id, function(err, redis_result)&#123; if(err) &#123; callback(false, agreement.redisErrorDesc); return ; &#125; if(redis_result != undefined) &#123; callback(true, JSON.parse(redis_result)); return ; &#125; callback(false, agreement.invalidSessionIdDesc); &#125;); &#125;)(session_id);&#125; 获取一个会话ID12345678910/** * 获取一个会话ID */function getNewSessionId() &#123; if(startVaule === 0) &#123; startVaule = parseInt(new Date().getTime()); &#125; startVaule++; return SESSION_ID_HEAD + startVaule;&#125; 调用示例1234567891011121314151617181920212223242526272829303132function login(user_id, passwords, callback) &#123; user_db.isUserIdExit(dbmanager.getClientS(), user_id, passwords,function(errorcode, result) &#123; if(errorcode === 0) &#123; successGetUserLoginInfo(result,callback); &#125;else &#123; if(errorcode === 201) &#123; callback(agreement.dbErrorDesc); &#125;else &#123; callback(agreement.noUserInfoDesc); &#125; &#125; &#125;);&#125;// 去DB查询用户信息并更新缓存function successGetUserLoginInfo(result, callback) &#123; (function(result)&#123; player_logic.getPlayerInfo(result.user_id, result.fortune_id, function(success, user_result)&#123; var clientResult; if(success) &#123; var session_id = session_manager.getNewSessionId(); var newResult = createUserSessionInfo(session_id, result, user_result); session_manager.LogicIn(newResult,session_id); clientResult = getLoginSuccessInfo(newResult.session_id); &#125; else &#123; clientResult = agreement.dbErrorDesc; &#125; console.log('clientResult : ' + JSON.stringify(clientResult)); callback(JSON.stringify(clientResult)); &#125;); &#125;)(result);&#125;","tags":[{"name":"node.js学习","slug":"node-js学习","permalink":"http://yoursite.com/tags/node-js学习/"}]},{"title":"node调用mysql","date":"2017-01-24T07:11:45.656Z","path":"2017/01/24/node_mysql/","text":"node.js与mysql交互。 npm安装1npm install mysql 使用案例初始化123456789101112131415161718192021222324252627282930function initClient(callback) &#123; option = &#123; host : config.mysql_catchfish_debug.host, port : config.mysql_catchfish_debug.port, user : config.mysql_catchfish_debug.user, password : config.mysql_catchfish_debug.password, database : config.mysql_catchfish_debug.database &#125;; client = mysql.createConnection(option); client.connect(function (err) &#123; if (err) &#123; console.log('initClient [[mysql db]]error when connecting to db:requestConnectMySqlTime = ' + requestConnectMySqlTime + ';err = ', err); requestConnectMySqlTime++; setTimeout(initClient, 5*1000);// TODO : if retry time over 3, need send mail callback(false); &#125;else &#123; requestConnectMySqlTime = 0; callback(true); &#125; &#125;); client.on('error', function (err) &#123; console.log('initClient db error', err); if (err.code === 'PROTOCOL_CONNECTION_LOST') &#123; // 如果是连接断开，自动重新连接 initClient(function(result)&#123; console.log('reconnect db result : ' + result); &#125;); &#125; &#125;);&#125; 调用12345678910111213141516function syncPlayerBaseFortuneInfo(client, sync_info, callback) &#123; var values = [ [sync_info.user_id, sync_info.coins, sync_info.diamonds, sync_info.exps, sync_info.turrent_level] ]; client.query(' INSERT INTO user_fortune_' + sync_info.fortune_id + ' (user_id, coins, diamonds, exp, turrent_level) VALUES ? ' + ' ON DUPLICATE KEY UPDATE coins = VALUES(coins),' + ' diamonds = VALUES(diamonds) , exp = VALUES(exp), turrent_level = VALUES(turrent_level)', [values], function (err, results) &#123; if (err) &#123; callback(false); return; &#125; callback(true); &#125;);&#125;","tags":[{"name":"node.js学习","slug":"node-js学习","permalink":"http://yoursite.com/tags/node-js学习/"}]},{"title":"二叉树的实现（c++）","date":"2017-01-24T07:11:45.656Z","path":"2017/01/24/DataStructure_BinaryTree/","text":"github : https://github.com/ckj258/DataStructure/tree/master/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91 二叉树节点定义123456789101112struct BinarySearchTreeNode&#123; int key; BinarySearchTreeNode *leftChild; BinarySearchTreeNode *rightChild; BinarySearchTreeNode(int tempKey) &#123; key=tempKey; leftChild=NULL; rightChild=NULL; &#125;&#125;; 头文件1234567891011121314151617class BinarySearchTree&#123;private: BinarySearchTreeNode *Root;public: BinarySearchTree(); BinarySearchTreeNode *GetRoot(); BinarySearchTreeNode *FindBST(int ); void UpdataBSTNode(int,int); void InsertBSTNode(int); bool DeleteBSTNode(int); void DeleteNoOrOneChildBSTNode(BinarySearchTreeNode *,BinarySearchTreeNode *); void PreOrderBSTPrint(BinarySearchTreeNode *); void InOrderBSTPrint(BinarySearchTreeNode *); void SufOrderBSTPrint(BinarySearchTreeNode *); void RotateBSTPrint(BinarySearchTreeNode *,int);&#125;; 返回二叉查找树根节点123456789/***********************************************************参数：无*返回值：空*功能：返回二叉查找树根节点************************************************************/BinarySearchTreeNode *BinarySearchTree::GetRoot()&#123; return this-&gt;Root;&#125; 查找节点123456789101112131415161718/***********************************************************参数：待查找值*返回值：若找到则返回所在节点，否则返回NULL*功能：查找节点************************************************************/BinarySearchTreeNode *BinarySearchTree::FindBST(int tempKey)&#123; BinarySearchTreeNode *cur=this-&gt;Root; while(cur!=NULL) &#123; if(cur-&gt;key==tempKey) break; else if(cur-&gt;key&gt;tempKey) cur=cur-&gt;leftChild; else cur=cur-&gt;rightChild; &#125; return cur;&#125; 返回二叉查找树根节点123456789/***********************************************************参数：无*返回值：空*功能：返回二叉查找树根节点************************************************************/BinarySearchTreeNode *BinarySearchTree::GetRoot()&#123; return this-&gt;Root;&#125; 插入新结点123456789101112131415161718192021222324/***********************************************************参数：待插入值*返回值：空*功能：插入新结点************************************************************/void BinarySearchTree::InsertBSTNode(int tempKey)&#123; BinarySearchTreeNode *pre=NULL,*cur=this-&gt;Root; while(cur!=NULL) &#123; pre=cur; if(cur-&gt;key&gt;tempKey)//tempKey插到左子树 cur=cur-&gt;leftChild; else cur=cur-&gt;rightChild;//插到左子树 &#125; BinarySearchTreeNode *tempNode=new BinarySearchTreeNode(tempKey); if(pre==NULL)//若插入的为根节点 &#123; this-&gt;Root=tempNode; &#125; else if(pre-&gt;key&gt;tempNode-&gt;key) pre-&gt;leftChild=tempNode; else pre-&gt;rightChild=tempNode;&#125; 更新节点元素12345678910/***********************************************************参数：待修改数值oldKey,修改后的数值newKey*返回值：空*功能：更新节点元素************************************************************/void BinarySearchTree::UpdataBSTNode(int oldKey,int newKey)&#123; DeleteBSTNode(oldKey); InsertBSTNode(newKey);&#125; 删除左右孩子有为空的情况12345678910111213141516171819202122232425262728293031323334353637/***********************************************************参数：pre待删除节点的父节点，cur待删除节点*返回值：空*功能：删除左右孩子有为空的情况************************************************************/void BinarySearchTree::DeleteNoOrOneChildBSTNode(BinarySearchTreeNode *pre,BinarySearchTreeNode *cur)&#123; if(NULL==cur-&gt;leftChild&amp;&amp;NULL==cur-&gt;rightChild)//左右孩子为空 &#123; if(NULL==pre) Root=NULL; else if(pre-&gt;leftChild==cur) pre-&gt;leftChild=NULL; else pre-&gt;rightChild=NULL; delete cur; &#125; else if(cur-&gt;rightChild!=NULL)//若右子树不为空 &#123; if(NULL==pre) Root=cur-&gt;rightChild; else if(pre-&gt;leftChild==cur) pre-&gt;leftChild=cur-&gt;rightChild; else pre-&gt;rightChild=cur-&gt;rightChild; delete cur; &#125; else if(cur-&gt;leftChild!=NULL)//若左子树不为空 &#123; if(NULL==pre) Root=cur-&gt;leftChild; else if(pre-&gt;leftChild==cur) pre-&gt;leftChild=cur-&gt;leftChild; else pre-&gt;rightChild=cur-&gt;leftChild; delete cur; &#125;&#125; 删除元素主函数1234567891011121314151617181920212223242526272829303132333435/***********************************************************参数：待删除节点元素*返回值：空*功能：删除元素主函数************************************************************/bool BinarySearchTree::DeleteBSTNode(int tempKey)&#123; BinarySearchTreeNode *pre=NULL,*cur=Root; while(cur!=NULL)//寻找待删除元素 &#123; if(cur-&gt;key==tempKey) break; else &#123; pre=cur; if(cur-&gt;key&gt;tempKey) cur=cur-&gt;leftChild; else cur=cur-&gt;rightChild; &#125; &#125; if(NULL==cur)return false; if(NULL==cur-&gt;leftChild||NULL==cur-&gt;rightChild) DeleteNoOrOneChildBSTNode(pre,cur); else //左右子树都不为空 &#123; BinarySearchTreeNode *rPre=cur,*rCur=cur-&gt;rightChild;//找到右子树最小元素 while(rCur-&gt;leftChild!=NULL) &#123; rPre=rCur; rCur=rCur-&gt;leftChild; &#125; cur-&gt;key=rCur-&gt;key; DeleteNoOrOneChildBSTNode(rPre,rCur); &#125;&#125; 前序遍历二叉查找树12345678910111213/***********************************************************参数：当前子树根节点*返回值：空*功能：前序遍历二叉查找树************************************************************/void BinarySearchTree::PreOrderBSTPrint(BinarySearchTreeNode *tempRoot)&#123; if(NULL==tempRoot) return ; cout&lt;&lt;tempRoot-&gt;key&lt;&lt;\" \"; PreOrderBSTPrint(tempRoot-&gt;leftChild); PreOrderBSTPrint(tempRoot-&gt;rightChild);&#125; 中序遍历二叉查找树12345678910111213/***********************************************************参数：当前子树根节点*返回值：空*功能：中序遍历二叉查找树************************************************************/void BinarySearchTree::InOrderBSTPrint(BinarySearchTreeNode *tempRoot)&#123; if(NULL==tempRoot) return ; InOrderBSTPrint(tempRoot-&gt;leftChild); cout&lt;&lt;tempRoot-&gt;key&lt;&lt;\" \"; InOrderBSTPrint(tempRoot-&gt;rightChild);&#125; 后序遍历二叉查找树树12345678910111213/***********************************************************参数：当前子树根节点*返回值：空*功能：后序遍历二叉查找树树************************************************************/void BinarySearchTree::SufOrderBSTPrint(BinarySearchTreeNode *tempRoot)&#123; if(NULL==tempRoot) return ; SufOrderBSTPrint(tempRoot-&gt;leftChild); SufOrderBSTPrint(tempRoot-&gt;rightChild); cout&lt;&lt;tempRoot-&gt;key&lt;&lt;\" \";&#125; 翻转打印二叉查找树123456789101112131415/***********************************************************参数：当前子树根节点，缩进列数*返回值：空*功能：翻转打印二叉查找树************************************************************/void BinarySearchTree::RotateBSTPrint(BinarySearchTreeNode *tempRoot,int tempColumn)&#123; if(NULL==tempRoot) return ; RotateBSTPrint(tempRoot-&gt;leftChild,tempColumn+1); for(int i=0;i&lt;tempColumn;i++) cout&lt;&lt;\" \"; cout&lt;&lt;\"---\"&lt;&lt;tempRoot-&gt;key&lt;&lt;endl; RotateBSTPrint(tempRoot-&gt;rightChild,tempColumn+1);&#125; test example1234567891011121314151617181920212223242526272829303132333435363738int main()&#123; int val; while(true) &#123; BinarySearchTree myBinarySearchTree; while(cin&gt;&gt;val) &#123; if(val==0)break; myBinarySearchTree.InsertBSTNode(val); &#125; cout&lt;&lt;endl&lt;&lt;\"*****************************\"&lt;&lt;endl; myBinarySearchTree.PreOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.InOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.SufOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.RotateBSTPrint(myBinarySearchTree.GetRoot(),0); cout&lt;&lt;endl&lt;&lt;\"*****************************\"&lt;&lt;endl; while(cin&gt;&gt;val) &#123; if(!val)break; myBinarySearchTree.DeleteBSTNode(val); cout&lt;&lt;endl&lt;&lt;\"*****************************\"&lt;&lt;endl; myBinarySearchTree.PreOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.InOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.SufOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.RotateBSTPrint(myBinarySearchTree.GetRoot(),0); cout&lt;&lt;endl&lt;&lt;\"*****************************\"&lt;&lt;endl; &#125; &#125; system(\"pause\"); return 0;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"redis配置参数说明","date":"2017-01-17T02:32:49.000Z","path":"2017/01/17/redis_option/","text":"redis配置参数说明参数说明redis.conf 配置项说明如下： Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 6379 绑定的主机地址 bind 127.0.0.1 当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 300 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id databases 16 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合save seconds changes Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb 指定本地数据库存放目录 dir ./ 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof 当master服务设置了密码保护时，slav服务连接master的密码 masterauth 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭 requirepass foobared 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 128 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof 指定更新日志条件，共有3个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 0 Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 32 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 134217728 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 4 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-value 512 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf","tags":[{"name":"node.js学习","slug":"node-js学习","permalink":"http://yoursite.com/tags/node-js学习/"}]},{"title":"node调用redis","date":"2017-01-17T01:55:52.000Z","path":"2017/01/17/node_redis/","text":"REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 安装1npm install redis 使用案例初始化12345678910111213141516var password = \"ckj258\";var redis_host = \"127.0.0.1\";var redis_port = 3101;var redis_options = &#123;\"no_ready_check\":config.redis.no_ready_check&#125;;var client;function init() &#123; console.log('init redis ... ... '); client = redis.createClient(redis_port, redis_host, redis_options); client.on(\"error\", function (err) &#123; console.log(\"redis meet Error \" + err + ';' + redis_host + ';' + redis_port); setTimeout(init, 5*1000); // 5秒后重连 &#125;); client.auth(password);&#125; setVaule1234function setVaule(key, values) &#123; client.set(key, values);&#125; setValueWithExpire12345function setValueWithExpire(key, values) &#123; client.set(key, values); client.expire(key, expire); // 单位秒&#125; getVaule12345function getVaule(key, callback ) &#123; client.get(key, function(err, redis_result) &#123; callback(err, redis_result); &#125;);&#125; delVaule123function del(key) &#123; client.del(key);&#125; test123456789init();setVaule(\"name\",\"Dantel\");getVaule(\"name\",function(err,redis_result)&#123; if(!error) &#123; console.log(redis_result); &#125;&#125;); 运行结果","tags":[{"name":"node.js学习","slug":"node-js学习","permalink":"http://yoursite.com/tags/node-js学习/"}]},{"title":"redis的安装与部署","date":"2017-01-17T01:55:52.000Z","path":"2017/01/17/redis_generate/","text":"REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 运行redis下载下载地址 ：https://redis.io/Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip,解压后，将文件夹重新命名为 redis。 配置Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。参数说明 : https://ckj258.github.io/2017/01/17/redis_option/ 部署打开一个 cmd 窗口 使用cd命令切换目录/redis 运行 redis-server redis.conf。 使用这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。切换到redis目录下运行 redis-cli -h host -p port -a password(redis-cli -h 127.0.0.1 -p 6379)。设置键值对 set name Dantel取出键值对 get name","tags":[{"name":"node.js学习","slug":"node-js学习","permalink":"http://yoursite.com/tags/node-js学习/"}]},{"title":"pomelo学习入门笔记","date":"2016-12-20T08:55:19.000Z","path":"2016/12/20/pomelo-chatserver/","text":"github : https://github.com/ckj258/PomeloClient/game-server 前言pomelo是一个游戏服务器框架，使用很简单。它包括基础开发框架和一系列相关工具和库，可以帮助开发者省去游戏开发中枯燥的重复劳动和底层逻辑工作，让开发者可以更多地去关注游戏的具体逻辑，大大提高开发效率。 项目结构../app/： 存放游戏逻辑脚本../config/: 存放配置文件../logs/: 存放历史日志../node_modules/: 存放用到的npm包../app.js： pomelo入口../package.json: npm包配置文件 运行架构 代码架构app.js中声明了”connector”,”gate”,”chat”服务器服务器配置信息在config目录下，servers.json配置具体的应用服务器信息。在配置文件中，分为development和production两种环境，表示开发环境和产品环境1234567891011121314151617181920212223242526app.configure('production|development', 'connector', function()&#123; app.set('connectorConfig', &#123; connector : pomelo.connectors.hybridconnector, heartbeat : 3, useDict : true, useProtobuf : true &#125;);&#125;);app.configure('production|development', 'gate', function()&#123; app.set('connectorConfig', &#123; connector : pomelo.connectors.hybridconnector, useProtobuf : true &#125;);&#125;);// app configureapp.configure('production|development', function() &#123; // route configures app.route('chat', routeUtil.chat); // filter configures app.filter(pomelo.timeout());&#125;); “chat”服务器../servers/chat目录下包含hander和remote两个文件夹，其中hander下主要存放监听器，负责接收客户端发送请求做相应处理 12345678910111213141516171819202122232425262728handler.send = function(msg, session, next) &#123; var rid = session.get('rid'); var username = session.uid.split('*')[0]; var channelService = this.app.get('channelService'); var param = &#123; msg: msg.content, from: username, target: msg.target &#125;; channel = channelService.getChannel(rid, false); //the target is all users if(msg.target == '*') &#123; channel.pushMessage('onChat', param); &#125; //the target is specific user else &#123; var tuid = msg.target + '*' + rid; var tsid = channel.getMember(tuid)['sid']; channelService.pushMessageByUids('onChat', param, [&#123; uid: tuid, sid: tsid &#125;]); &#125; next(null, &#123; route: msg.route &#125;);&#125;; send方法主要功能是接收客户端发送的聊天信息，并广播给同channel下玩家，回调函数next()返回客户端错误码 至于remote，当有客户端连接到connector上后，connector会向chat.remote发起远程过程调用，chat.remote会将登录的用户，加到对应的channel中","tags":[{"name":"pomelo","slug":"pomelo","permalink":"http://yoursite.com/tags/pomelo/"}]},{"title":"pomelo服务器与cocos2d交互","date":"2016-12-13T06:30:00.000Z","path":"2016/12/13/pomelo-libpomelo/","text":"github : https://github.com/ckj258/PomeloClient/ Pomelo 是基于 Node.js 的高性能、分布式游戏服务器框架。非常适合用来开发轻量级手游。之前一直在用pomelo-cocos2dx架构，在此记录一下使用心得。 运行项目Clientcoco2dx引擎版本3.10，拷贝引擎文件至根目录编译，运行 Servercd game-servernpm installpomelo start 类详解PomeloSocket负责与server的交互主要方法12345678910111213141516void conConnect(const char*ServerIP, int ServerPort );//建立连接void quit(); //断开连接/* ============================================================================== * 功能描述：发送事件,回调函数 typedef void (*pc_notify_cb_t)(const pc_notify_t* req, int rc); rc表示错误码,无参数返回. 例用于上传游戏数据等等 * 创 建 者：ckj * 创建日期：2016年12月13日17:30:49 * ==============================================================================*/void sendEvents(const char* params, const char*remote, pc_notify_cb_t event_cb);/* ============================================================================== * 功能描述：发送请求,回调函数 typedef void (*pc_request_cb_t)(const pc_request_t* req, int rc, const char* resp); rc表示错误码,resp为服务器json结构. 例用于登录等需要返回结果的场景 * 创 建 者：ckj * 创建日期：2016年12月13日17:33:53 * ==============================================================================*/void sendRequest(const char* params, const char*remote, pc_request_cb_t request_cb); PomeloHandler观察者模式中的观察者，负责向游戏中注册监听的对象发放广播1void addHandlerListen(PomeloListen* listen);//添加监听listen PomeloListen观察者模式中的对象，一个纯虚类，负责接收消息1virtual void handle_event(const char* msgId, const char* msgBody)=0; //msgId为服务器notify分发的remote 调用方法因为pomelo基于分布式游戏服务器框架，所以进入游戏时最好通过http请求获取TCP连接ip和port然后调用onConnect建立连接 游戏中将需要注册监听的对象继承PomeloListen，重写handle_event()方法即可具体示例见ChatDialog.hpp ChatDialog.cpp 效果截图 界面粗糙，请勿见怪 platformandroid和mac自行链接对应库文件","tags":[{"name":"pomelo","slug":"pomelo","permalink":"http://yoursite.com/tags/pomelo/"}]},{"title":"Hello World","date":"2016-12-07T03:54:00.000Z","path":"2016/12/07/hello-world/","text":"前前后后折腾了一天，因为网速的关系，反反复复的安装，人生第一篇博客终于诞生。在此感谢 ”沸沸腾“ 提供的教程http://www.jianshu.com/p/863f3f2d1733以及 yilia作者“litten”提供的简约主题","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]}]