[{"title":"二叉树的实现（c++）","date":"2017-01-20T02:51:40.348Z","path":"2017/01/20/DataStructure_BinaryTree/","text":"github : https://github.com/ckj258/DataStructure/tree/master/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91 二叉树节点定义123456789101112struct BinarySearchTreeNode&#123; int key; BinarySearchTreeNode *leftChild; BinarySearchTreeNode *rightChild; BinarySearchTreeNode(int tempKey) &#123; key=tempKey; leftChild=NULL; rightChild=NULL; &#125;&#125;; 头文件1234567891011121314151617class BinarySearchTree&#123;private: BinarySearchTreeNode *Root;public: BinarySearchTree(); BinarySearchTreeNode *GetRoot(); BinarySearchTreeNode *FindBST(int ); void UpdataBSTNode(int,int); void InsertBSTNode(int); bool DeleteBSTNode(int); void DeleteNoOrOneChildBSTNode(BinarySearchTreeNode *,BinarySearchTreeNode *); void PreOrderBSTPrint(BinarySearchTreeNode *); void InOrderBSTPrint(BinarySearchTreeNode *); void SufOrderBSTPrint(BinarySearchTreeNode *); void RotateBSTPrint(BinarySearchTreeNode *,int);&#125;; 返回二叉查找树根节点123456789/***********************************************************参数：无*返回值：空*功能：返回二叉查找树根节点************************************************************/BinarySearchTreeNode *BinarySearchTree::GetRoot()&#123; return this-&gt;Root;&#125; 查找节点123456789101112131415161718/***********************************************************参数：待查找值*返回值：若找到则返回所在节点，否则返回NULL*功能：查找节点************************************************************/BinarySearchTreeNode *BinarySearchTree::FindBST(int tempKey)&#123; BinarySearchTreeNode *cur=this-&gt;Root; while(cur!=NULL) &#123; if(cur-&gt;key==tempKey) break; else if(cur-&gt;key&gt;tempKey) cur=cur-&gt;leftChild; else cur=cur-&gt;rightChild; &#125; return cur;&#125; 返回二叉查找树根节点123456789/***********************************************************参数：无*返回值：空*功能：返回二叉查找树根节点************************************************************/BinarySearchTreeNode *BinarySearchTree::GetRoot()&#123; return this-&gt;Root;&#125; 插入新结点123456789101112131415161718192021222324/***********************************************************参数：待插入值*返回值：空*功能：插入新结点************************************************************/void BinarySearchTree::InsertBSTNode(int tempKey)&#123; BinarySearchTreeNode *pre=NULL,*cur=this-&gt;Root; while(cur!=NULL) &#123; pre=cur; if(cur-&gt;key&gt;tempKey)//tempKey插到左子树 cur=cur-&gt;leftChild; else cur=cur-&gt;rightChild;//插到左子树 &#125; BinarySearchTreeNode *tempNode=new BinarySearchTreeNode(tempKey); if(pre==NULL)//若插入的为根节点 &#123; this-&gt;Root=tempNode; &#125; else if(pre-&gt;key&gt;tempNode-&gt;key) pre-&gt;leftChild=tempNode; else pre-&gt;rightChild=tempNode;&#125; 更新节点元素12345678910/***********************************************************参数：待修改数值oldKey,修改后的数值newKey*返回值：空*功能：更新节点元素************************************************************/void BinarySearchTree::UpdataBSTNode(int oldKey,int newKey)&#123; DeleteBSTNode(oldKey); InsertBSTNode(newKey);&#125; 删除左右孩子有为空的情况12345678910111213141516171819202122232425262728293031323334353637/***********************************************************参数：pre待删除节点的父节点，cur待删除节点*返回值：空*功能：删除左右孩子有为空的情况************************************************************/void BinarySearchTree::DeleteNoOrOneChildBSTNode(BinarySearchTreeNode *pre,BinarySearchTreeNode *cur)&#123; if(NULL==cur-&gt;leftChild&amp;&amp;NULL==cur-&gt;rightChild)//左右孩子为空 &#123; if(NULL==pre) Root=NULL; else if(pre-&gt;leftChild==cur) pre-&gt;leftChild=NULL; else pre-&gt;rightChild=NULL; delete cur; &#125; else if(cur-&gt;rightChild!=NULL)//若右子树不为空 &#123; if(NULL==pre) Root=cur-&gt;rightChild; else if(pre-&gt;leftChild==cur) pre-&gt;leftChild=cur-&gt;rightChild; else pre-&gt;rightChild=cur-&gt;rightChild; delete cur; &#125; else if(cur-&gt;leftChild!=NULL)//若左子树不为空 &#123; if(NULL==pre) Root=cur-&gt;leftChild; else if(pre-&gt;leftChild==cur) pre-&gt;leftChild=cur-&gt;leftChild; else pre-&gt;rightChild=cur-&gt;leftChild; delete cur; &#125;&#125; 删除元素主函数1234567891011121314151617181920212223242526272829303132333435/***********************************************************参数：待删除节点元素*返回值：空*功能：删除元素主函数************************************************************/bool BinarySearchTree::DeleteBSTNode(int tempKey)&#123; BinarySearchTreeNode *pre=NULL,*cur=Root; while(cur!=NULL)//寻找待删除元素 &#123; if(cur-&gt;key==tempKey) break; else &#123; pre=cur; if(cur-&gt;key&gt;tempKey) cur=cur-&gt;leftChild; else cur=cur-&gt;rightChild; &#125; &#125; if(NULL==cur)return false; if(NULL==cur-&gt;leftChild||NULL==cur-&gt;rightChild) DeleteNoOrOneChildBSTNode(pre,cur); else //左右子树都不为空 &#123; BinarySearchTreeNode *rPre=cur,*rCur=cur-&gt;rightChild;//找到右子树最小元素 while(rCur-&gt;leftChild!=NULL) &#123; rPre=rCur; rCur=rCur-&gt;leftChild; &#125; cur-&gt;key=rCur-&gt;key; DeleteNoOrOneChildBSTNode(rPre,rCur); &#125;&#125; 前序遍历二叉查找树12345678910111213/***********************************************************参数：当前子树根节点*返回值：空*功能：前序遍历二叉查找树************************************************************/void BinarySearchTree::PreOrderBSTPrint(BinarySearchTreeNode *tempRoot)&#123; if(NULL==tempRoot) return ; cout&lt;&lt;tempRoot-&gt;key&lt;&lt;\" \"; PreOrderBSTPrint(tempRoot-&gt;leftChild); PreOrderBSTPrint(tempRoot-&gt;rightChild);&#125; 中序遍历二叉查找树12345678910111213/***********************************************************参数：当前子树根节点*返回值：空*功能：中序遍历二叉查找树************************************************************/void BinarySearchTree::InOrderBSTPrint(BinarySearchTreeNode *tempRoot)&#123; if(NULL==tempRoot) return ; InOrderBSTPrint(tempRoot-&gt;leftChild); cout&lt;&lt;tempRoot-&gt;key&lt;&lt;\" \"; InOrderBSTPrint(tempRoot-&gt;rightChild);&#125; 后序遍历二叉查找树树12345678910111213/***********************************************************参数：当前子树根节点*返回值：空*功能：后序遍历二叉查找树树************************************************************/void BinarySearchTree::SufOrderBSTPrint(BinarySearchTreeNode *tempRoot)&#123; if(NULL==tempRoot) return ; SufOrderBSTPrint(tempRoot-&gt;leftChild); SufOrderBSTPrint(tempRoot-&gt;rightChild); cout&lt;&lt;tempRoot-&gt;key&lt;&lt;\" \";&#125; 翻转打印二叉查找树123456789101112131415/***********************************************************参数：当前子树根节点，缩进列数*返回值：空*功能：翻转打印二叉查找树************************************************************/void BinarySearchTree::RotateBSTPrint(BinarySearchTreeNode *tempRoot,int tempColumn)&#123; if(NULL==tempRoot) return ; RotateBSTPrint(tempRoot-&gt;leftChild,tempColumn+1); for(int i=0;i&lt;tempColumn;i++) cout&lt;&lt;\" \"; cout&lt;&lt;\"---\"&lt;&lt;tempRoot-&gt;key&lt;&lt;endl; RotateBSTPrint(tempRoot-&gt;rightChild,tempColumn+1);&#125; test example1234567891011121314151617181920212223242526272829303132333435363738int main()&#123; int val; while(true) &#123; BinarySearchTree myBinarySearchTree; while(cin&gt;&gt;val) &#123; if(val==0)break; myBinarySearchTree.InsertBSTNode(val); &#125; cout&lt;&lt;endl&lt;&lt;\"*****************************\"&lt;&lt;endl; myBinarySearchTree.PreOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.InOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.SufOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.RotateBSTPrint(myBinarySearchTree.GetRoot(),0); cout&lt;&lt;endl&lt;&lt;\"*****************************\"&lt;&lt;endl; while(cin&gt;&gt;val) &#123; if(!val)break; myBinarySearchTree.DeleteBSTNode(val); cout&lt;&lt;endl&lt;&lt;\"*****************************\"&lt;&lt;endl; myBinarySearchTree.PreOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.InOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.SufOrderBSTPrint(myBinarySearchTree.GetRoot()); cout&lt;&lt;endl&lt;&lt;\"=============================\"&lt;&lt;endl; myBinarySearchTree.RotateBSTPrint(myBinarySearchTree.GetRoot(),0); cout&lt;&lt;endl&lt;&lt;\"*****************************\"&lt;&lt;endl; &#125; &#125; system(\"pause\"); return 0;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"redis配置参数说明","date":"2017-01-17T02:32:49.000Z","path":"2017/01/17/redis_option/","text":"redis配置参数说明参数说明redis.conf 配置项说明如下： Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 6379 绑定的主机地址 bind 127.0.0.1 当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 300 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id databases 16 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合save seconds changes Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb 指定本地数据库存放目录 dir ./ 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof 当master服务设置了密码保护时，slav服务连接master的密码 masterauth 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭 requirepass foobared 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 128 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof 指定更新日志条件，共有3个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 0 Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 32 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 134217728 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 4 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-value 512 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf","tags":[{"name":"node.js学习","slug":"node-js学习","permalink":"http://yoursite.com/tags/node-js学习/"}]},{"title":"node调用redis","date":"2017-01-17T01:55:52.000Z","path":"2017/01/17/node_redis/","text":"REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 安装1npm install redis 使用案例初始化12345678910111213141516var password = \"ckj258\";var redis_host = \"127.0.0.1\";var redis_port = 3101;var redis_options = &#123;\"no_ready_check\":config.redis.no_ready_check&#125;;var client;function init() &#123; console.log('init redis ... ... '); client = redis.createClient(redis_port, redis_host, redis_options); client.on(\"error\", function (err) &#123; console.log(\"redis meet Error \" + err + ';' + redis_host + ';' + redis_port); setTimeout(init, 5*1000); // 5秒后重连 &#125;); client.auth(password);&#125; setVaule1234function setVaule(key, values) &#123; client.set(key, values);&#125; setValueWithExpire12345function setValueWithExpire(key, values) &#123; client.set(key, values); client.expire(key, expire); // 单位秒&#125; getVaule12345function getVaule(key, callback ) &#123; client.get(key, function(err, redis_result) &#123; callback(err, redis_result); &#125;);&#125; delVaule123function del(key) &#123; client.del(key);&#125; test123456789init();setVaule(&quot;name&quot;,&quot;Dantel&quot;);getVaule(&quot;name&quot;,function(err,redis_result)&#123; if(!error) &#123; console.log(redis_result); &#125;&#125;); 运行结果","tags":[{"name":"node.js学习","slug":"node-js学习","permalink":"http://yoursite.com/tags/node-js学习/"}]},{"title":"redis的安装与部署","date":"2017-01-17T01:55:52.000Z","path":"2017/01/17/redis_generate/","text":"REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 运行redis下载下载地址 ：https://redis.io/Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip,解压后，将文件夹重新命名为 redis。 配置Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。参数说明 : https://ckj258.github.io/2017/01/17/redis_option/ 部署打开一个 cmd 窗口 使用cd命令切换目录/redis 运行 redis-server redis.conf。 使用这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。切换到redis目录下运行 redis-cli -h host -p port -a password(redis-cli -h 127.0.0.1 -p 6379)。设置键值对 set name Dantel取出键值对 get name","tags":[{"name":"node.js学习","slug":"node-js学习","permalink":"http://yoursite.com/tags/node-js学习/"}]},{"title":"pomelo学习入门笔记","date":"2016-12-20T08:55:19.000Z","path":"2016/12/20/pomelo-chatserver/","text":"github : https://github.com/ckj258/PomeloClient/game-server 前言pomelo是一个游戏服务器框架，使用很简单。它包括基础开发框架和一系列相关工具和库，可以帮助开发者省去游戏开发中枯燥的重复劳动和底层逻辑工作，让开发者可以更多地去关注游戏的具体逻辑，大大提高开发效率。 项目结构../app/： 存放游戏逻辑脚本../config/: 存放配置文件../logs/: 存放历史日志../node_modules/: 存放用到的npm包../app.js： pomelo入口../package.json: npm包配置文件 运行架构 代码架构app.js中声明了”connector”,”gate”,”chat”服务器服务器配置信息在config目录下，servers.json配置具体的应用服务器信息。在配置文件中，分为development和production两种环境，表示开发环境和产品环境1234567891011121314151617181920212223242526app.configure(&apos;production|development&apos;, &apos;connector&apos;, function()&#123; app.set(&apos;connectorConfig&apos;, &#123; connector : pomelo.connectors.hybridconnector, heartbeat : 3, useDict : true, useProtobuf : true &#125;);&#125;);app.configure(&apos;production|development&apos;, &apos;gate&apos;, function()&#123; app.set(&apos;connectorConfig&apos;, &#123; connector : pomelo.connectors.hybridconnector, useProtobuf : true &#125;);&#125;);// app configureapp.configure(&apos;production|development&apos;, function() &#123; // route configures app.route(&apos;chat&apos;, routeUtil.chat); // filter configures app.filter(pomelo.timeout());&#125;); “chat”服务器../servers/chat目录下包含hander和remote两个文件夹，其中hander下主要存放监听器，负责接收客户端发送请求做相应处理 12345678910111213141516171819202122232425262728handler.send = function(msg, session, next) &#123; var rid = session.get(&apos;rid&apos;); var username = session.uid.split(&apos;*&apos;)[0]; var channelService = this.app.get(&apos;channelService&apos;); var param = &#123; msg: msg.content, from: username, target: msg.target &#125;; channel = channelService.getChannel(rid, false); //the target is all users if(msg.target == &apos;*&apos;) &#123; channel.pushMessage(&apos;onChat&apos;, param); &#125; //the target is specific user else &#123; var tuid = msg.target + &apos;*&apos; + rid; var tsid = channel.getMember(tuid)[&apos;sid&apos;]; channelService.pushMessageByUids(&apos;onChat&apos;, param, [&#123; uid: tuid, sid: tsid &#125;]); &#125; next(null, &#123; route: msg.route &#125;);&#125;; send方法主要功能是接收客户端发送的聊天信息，并广播给同channel下玩家，回调函数next()返回客户端错误码 至于remote，当有客户端连接到connector上后，connector会向chat.remote发起远程过程调用，chat.remote会将登录的用户，加到对应的channel中","tags":[{"name":"pomelo","slug":"pomelo","permalink":"http://yoursite.com/tags/pomelo/"}]},{"title":"pomelo服务器与cocos2d交互","date":"2016-12-13T06:30:00.000Z","path":"2016/12/13/pomelo-libpomelo/","text":"github : https://github.com/ckj258/PomeloClient/ Pomelo 是基于 Node.js 的高性能、分布式游戏服务器框架。非常适合用来开发轻量级手游。之前一直在用pomelo-cocos2dx架构，在此记录一下使用心得。 运行项目Clientcoco2dx引擎版本3.10，拷贝引擎文件至根目录编译，运行 Servercd game-servernpm installpomelo start 类详解PomeloSocket负责与server的交互主要方法123456789101112131415 void conConnect(const char*ServerIP, int ServerPort );//建立连接 void quit(); //断开连接/* ============================================================================== * 功能描述：发送事件,回调函数 typedef void (*pc_notify_cb_t)(const pc_notify_t* req, int rc); rc表示错误码,无参数返回. 例用于上传游戏数据等等 * 创 建 者：ckj * 创建日期：2016年12月13日17:30:49 * ==============================================================================*/ void sendEvents(const char* params, const char*remote, pc_notify_cb_t event_cb);/* ============================================================================== * 功能描述：发送请求,回调函数 typedef void (*pc_request_cb_t)(const pc_request_t* req, int rc, const char* resp); rc表示错误码,resp为服务器json结构. 例用于登录等需要返回结果的场景 * 创 建 者：ckj * 创建日期：2016年12月13日17:33:53 * ==============================================================================*/ void sendRequest(const char* params, const char*remote, pc_request_cb_t request_cb); PomeloHandler观察者模式中的观察者，负责向游戏中注册监听的对象发放广播1void addHandlerListen(PomeloListen* listen);//添加监听listen PomeloListen观察者模式中的对象，一个纯虚类，负责接收消息1virtual void handle_event(const char* msgId, const char* msgBody)=0; //msgId为服务器notify分发的remote 调用方法因为pomelo基于分布式游戏服务器框架，所以进入游戏时最好通过http请求获取TCP连接ip和port然后调用onConnect建立连接 游戏中将需要注册监听的对象继承PomeloListen，重写handle_event()方法即可具体示例见ChatDialog.hpp ChatDialog.cpp 效果截图 界面粗糙，请勿见怪 platformandroid和mac自行链接对应库文件","tags":[{"name":"pomelo","slug":"pomelo","permalink":"http://yoursite.com/tags/pomelo/"}]},{"title":"Hello World","date":"2016-12-07T03:54:00.000Z","path":"2016/12/07/hello-world/","text":"前前后后折腾了一天，因为网速的关系，反反复复的安装，人生第一篇博客终于诞生。在此感谢 ”沸沸腾“ 提供的教程http://www.jianshu.com/p/863f3f2d1733以及 yilia作者“litten”提供的简约主题","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]}]